var documenterSearchIndex = {"docs":
[{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This a package created as a list of helper functions for the main package TaskGraphs.jl. Please install this package first before running the TaskGraphs.jl package.","category":"page"},{"location":"getting_started/#GraphUtils.jl","page":"Getting Started","title":"GraphUtils.jl","text":"","category":"section"},{"location":"getting_started/#Installation:","page":"Getting Started","title":"Installation:","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"git add https://github.com/sisl/GraphUtils.jl","category":"page"},{"location":"getting_started/#Quick-Start","page":"Getting Started","title":"Quick Start","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To run a simple use case of topological sort.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using GraphUtils\nusing Graphs\nG = DiGraph(4);\nadd_edge!(G,1,2);\nadd_edge!(G,1,4);\nadd_edge!(G,2,3);\nadd_edge!(G,3,4);\nordering = GraphUtils.topological_sort(G);\nordering == [1,2,3,4]\n","category":"page"},{"location":"library/#Core-Types","page":"Core Types and Methods","title":"Core Types","text":"","category":"section"},{"location":"library/#Graph","page":"Core Types and Methods","title":"Graph","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"AbstractCustomNGraph\nget_graph\nget_vtx_ids\nget_vtx_map\nget_nodes\nnode_val\nedge_val\nedge_source\nedge_target\nreplace_node!\nadd_node!\nmake_node\nmake_edge\nadd_child!\nadd_parent!\nrem_node!\nis_terminal_node\nget_all_root_nodes\nget_all_terminal_nodes\nget_dist_matrix\ntopological_sort","category":"page"},{"location":"library/#GraphUtils.AbstractCustomNGraph","page":"Core Types and Methods","title":"GraphUtils.AbstractCustomNGraph","text":"abstract type AbstractCustomNGraph{G,N,ID} <: AbstractCustomGraph\n\nAn abstract Custom Graph type, with an underlying graph of type G, nodes of type N with ids of type ID. All concrete subtypes CG<:AbstractCustomNGraph must implement the following methods: get_graph(g::CG),get_vtx_ids(g::CG), get_vtx_map(g::CG), and get_nodes(g::CG). These methods are implemented by default if g::CG has the following fields:\n\ngraph     ::CG\nnodes     ::Vector{N}\nvtx_map   ::Dict{ID,Int}\nvtx_ids   ::Vector{ID}\n\nAbstract subtypes of AbstractCustomNGraph{G,N,ID} include:\n\nAbstractCustomNEGraph{G,N,E,ID} - a graph with custom edges of type E\n\n\n\n\n\n","category":"type"},{"location":"library/#GraphUtils.get_graph","page":"Core Types and Methods","title":"GraphUtils.get_graph","text":"get_graph(g::AbstractCustomNGraph{G,N,ID})\n\nreturn the underlying graph of type G.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.get_vtx_ids","page":"Core Types and Methods","title":"GraphUtils.get_vtx_ids","text":"get_vtx_ids(g::AbstractCustomNGraph{G,N,ID})\n\nreturn the vector Vector{ID} of g's unique vertex ids.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.get_vtx_map","page":"Core Types and Methods","title":"GraphUtils.get_vtx_map","text":"get_vtx_map(g::AbstractCustomNGraph{G,N,ID})\n\nreturn a data structure (e.g, a 'Dict{ID,Int}') mapping node id to node index.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.get_nodes","page":"Core Types and Methods","title":"GraphUtils.get_nodes","text":"get_nodes(g::AbstractCustomNGraph{G,N,ID})\n\nReturn the vector Vector{N} of g's nodes.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.node_val","page":"Core Types and Methods","title":"GraphUtils.node_val","text":"node_val(node)\n\nReturn the value associated with a node. Part of the optional node interface for nodes in an AbstractCustomNGraph.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.edge_val","page":"Core Types and Methods","title":"GraphUtils.edge_val","text":"edge_val(edge)\n\nReturns the value associated with an edge. Part of the optional interface for edges in an AbstractCustomNEGraph.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.edge_source","page":"Core Types and Methods","title":"GraphUtils.edge_source","text":"edge_source(edge)\n\nReturns the ID of the source node of an edge. Part of the required interface for edges in an AbstractCustomNEGraph.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.edge_target","page":"Core Types and Methods","title":"GraphUtils.edge_target","text":"edge_target(edge)\n\nReturns the ID of the target node of an edge. Part of the required interface for edges in an AbstractCustomNEGraph.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.replace_node!","page":"Core Types and Methods","title":"GraphUtils.replace_node!","text":"replace_node!(g::AbstractCustomNGraph{G,N,ID},node::N,id::ID) where {G,N,ID}\n\nReplace the current node associated with id with the new node node.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.add_node!","page":"Core Types and Methods","title":"GraphUtils.add_node!","text":"add_node!(g::AbstractCustomNGraph{G,N,ID},node::N,id::ID) where {G,N,ID}\n\nAdd node to g with associated id.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.make_node","page":"Core Types and Methods","title":"GraphUtils.make_node","text":"make_node(g::AbstractCustomNGraph{G,N,ID},val,id)\n\nConstruct a node of type N from val and id. This method must be implemented for whatever custom node type is used.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.make_edge","page":"Core Types and Methods","title":"GraphUtils.make_edge","text":"make_edge(g::G,u,v,val) where {G}\n\nConstruct an edge u → v of type _edge_type(g) based on val. Default behavior is to throw an error.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.add_child!","page":"Core Types and Methods","title":"GraphUtils.add_child!","text":"function add_child!(graph,parent,node,id)\n\nadd node child to graph with id id, then add edge parent → child\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.add_parent!","page":"Core Types and Methods","title":"GraphUtils.add_parent!","text":"function add_parent!(graph,child,parent,id)\n\nadd node parent to graph with id id, then add edge parent → child\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.rem_node!","page":"Core Types and Methods","title":"GraphUtils.rem_node!","text":"rem_node!\n\nremoves a node (by id) from g. Note about LightGraphs.rem_vertex!: \"internally the removal is performed swapping the vertices v and nv(G), and  removing the last vertex nv(G) from the graph\"\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.is_terminal_node","page":"Core Types and Methods","title":"GraphUtils.is_terminal_node","text":"`isroot_node(G,v)`\n\nInputs:\n    `G` - graph\n    `v` - query vertex\n\nOutputs:\n    returns `true` if vertex v has no outneighbors\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.get_all_root_nodes","page":"Core Types and Methods","title":"GraphUtils.get_all_root_nodes","text":"`get_all_root_nodes`\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.get_all_terminal_nodes","page":"Core Types and Methods","title":"GraphUtils.get_all_terminal_nodes","text":"`get_all_terminal_nodes`\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.get_dist_matrix","page":"Core Types and Methods","title":"GraphUtils.get_dist_matrix","text":"`get_dist_matrix(G)`\n\nGet the distance matrix corresponding to the edge weights of a graph\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.topological_sort","page":"Core Types and Methods","title":"GraphUtils.topological_sort","text":"topological_sort(G)\n\nReturns a topological sort of the vertices of a graph, with the property that v1 < v2 iff there is not forward path through the graph from v2 to v1. G must be non-cyclic. Can handle disjoint graphs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Tree","page":"Core Types and Methods","title":"Tree","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"AbstractCustomNTree\nAbstractTreeNode\nvalidate_tree\nvalidate_embedded_tree","category":"page"},{"location":"library/#GraphUtils.AbstractCustomNTree","page":"Core Types and Methods","title":"GraphUtils.AbstractCustomNTree","text":"abstract type AbstractCustomNTree{N,ID} <: AbstractCustomNDiGraph{N,ID}\n\nAbstract custom graph type with tree edge structure.\n\n\n\n\n\n","category":"type"},{"location":"library/#GraphUtils.AbstractTreeNode","page":"Core Types and Methods","title":"GraphUtils.AbstractTreeNode","text":"abstract type AbstractTreeNode{E,ID}\n\nE is element type, ID is id type\n\n\n\n\n\n","category":"type"},{"location":"library/#GraphUtils.validate_tree","page":"Core Types and Methods","title":"GraphUtils.validate_tree","text":"validate_tree(n::AbstractTreeNode)\n\nEnsure that the transform tree is in fact a tree–no cycles, and no duplicate ids\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.validate_embedded_tree","page":"Core Types and Methods","title":"GraphUtils.validate_embedded_tree","text":"validate_embedded_tree(graph,f=v->get_node(graph,v))\n\nVerify that all graph edges are mirrored by the parent-child structure stored in the nodes.\n\n\n\n\n\n","category":"function"},{"location":"library/#Factory-World","page":"Core Types and Methods","title":"Factory World","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"construct_vtx_map\nconstruct_edge_cache\nconstruct_expanded_zones\nvalidate_expanded_zones\nSparseDistanceMatrix\nremap_idx\nrecompute_cached_distances!\nconfig_index_to_tuple\nRemappedDistanceMatrix\nGridFactoryEnvironment\nconstruct_regular_factory_world\nconstruct_factory_env_from_vtx_grid\nconstruct_factory_env_from_indicator_grid","category":"page"},{"location":"library/#GraphUtils.construct_vtx_map","page":"Core Types and Methods","title":"GraphUtils.construct_vtx_map","text":"construct_vtx_map(vtxs,dims)\n\nReturns a matrix M such that MV[i,j] == v, where v is the index of the vertex whose coordinates are (i,j)\n\nArguments:\n\nvtxs : a list of integer coordinates\ndims : the dimensions of the grid\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.construct_edge_cache","page":"Core Types and Methods","title":"GraphUtils.construct_edge_cache","text":"construct_edge_cache(vtxs,vtx_map)\n\nReturns a cache such that cache[v] = {(0,1),(0,0),...}, the set of all valid directions in which a robot may move from vertex v.\n\nArguments:\n\nvtxs : a list of integer coordinates\nvtxmap : a matrix such that  `vtxmap[i,j] = v, wherevtxs[i,j] = v`.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.construct_expanded_zones","page":"Core Types and Methods","title":"GraphUtils.construct_expanded_zones","text":"construct_expanded_zones(vtxs,vtx_map,pickup_zones,dropoff_zones;\n    shapes=[(1,1),(1,2),(2,1),(2,2)])\n\nA utility for constructing drop-off/pick-up zones where large-footprint objects need to be delivered. Returns a dictionary mapping vertices to a dict of shape=>vtxs for expanded size delivery zones. For each starting vertex, the expanded zone is selected as the appropriately sized region that overlaps with the original vertex, does not overlap with any obstacles, and has minimal overlap with all other vertices in the zone list.\n\nArguments:\n\nvtxs : a list of integer coordinates\nvtxmap : a matrix such that `vtxmap[i,j] == v, wherevtxs[v] == (i,j)`\nzones : a list of integer vertex indices identifying the zones to be   expanded\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.validate_expanded_zones","page":"Core Types and Methods","title":"GraphUtils.validate_expanded_zones","text":"validate_expanded_zones(vtx_map,expanded_zones)\n\nVerify that all vertices of each expanded zone do not overlap with obstacle regions, and that each expanded zone contains the original vertex.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.SparseDistanceMatrix","page":"Core Types and Methods","title":"GraphUtils.SparseDistanceMatrix","text":"SparseDistanceMatrix{G,M}\n\nStores a graph and sparse distance matrix. When the distance matrix is queried for the distance between start and goal, it first checks that this distance has been computed. If not, it will first compute the distances from all nodes to goal before returning the queried distance.\n\n\n\n\n\n","category":"type"},{"location":"library/#GraphUtils.remap_idx","page":"Core Types and Methods","title":"GraphUtils.remap_idx","text":"remap_idx(m::SparseDistanceMatrix,v,config)\n\nMaps an index and configuration from the base grid to the transformed grid represented by m.graph. config represents the position of the query pt relative to the coordinates that correspond to v.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.recompute_cached_distances!","page":"Core Types and Methods","title":"GraphUtils.recompute_cached_distances!","text":"recompute_cached_distances!\n\nRecompute all cached distances (important if, e.g., the graph has been modified)\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.config_index_to_tuple","page":"Core Types and Methods","title":"GraphUtils.config_index_to_tuple","text":"config_index_to_tuple(shape::Tuple{Int,Int}, idx::Int)\n\nConvert a config index to a tuple coordinate representation. Assumes the following layout for config indices given shape (m,n):           1          2         ... n          ____________________________     1   | 1          2         ... n     2   | n+1        n+2       ... 2n     ... |     m   | (m-1)n+1  (m-1)n+2 ... m*n\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.RemappedDistanceMatrix","page":"Core Types and Methods","title":"GraphUtils.RemappedDistanceMatrix","text":"RemappedDistanceMatrix\n\nStores a distance matrix that corresponds to a \"shifted\" grid graph with a new configuration space layered over a base graph. The shape m.s of m::RemappedDistanceMatrix defines the convolution kernel used to generate the modified.\n\n\n\n\n\n","category":"type"},{"location":"library/#GraphUtils.GridFactoryEnvironment","page":"Core Types and Methods","title":"GraphUtils.GridFactoryEnvironment","text":"GridFactoryEnvironment\n\n\n\n\n\n","category":"type"},{"location":"library/#GraphUtils.construct_regular_factory_world","page":"Core Types and Methods","title":"GraphUtils.construct_regular_factory_world","text":"construct_regular_factory_world()\n\nReturns a GridFactoryEnvironment with regularly spaced obstacle regions surrounded by alternating pick-up and drop-off locations.\n\nKeyword Arguments:\n\nnobstaclesx = 2 : number of obstacles in x direction\nnobstaclesy = 2 : number of obstacles in y direction\nobs_width = [2;2] : obstacle width in both directions\nobs_offset = [1;1] : width of buffer region around each obstacle\nenv_pad = [1;1] : env pad\nenv_scale = 0.5 : determines the width of each grid cell when the   coordinates of the environment are transformed to continuous Cartesian   space.\ntransition_time = 2.0 : determines the nominal travel time for a robot   to move from one grid cell to an adjacent one.\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.construct_factory_env_from_vtx_grid","page":"Core Types and Methods","title":"GraphUtils.construct_factory_env_from_vtx_grid","text":"construct_factory_env_from_vtx_grid(vtx_grid;kwargs...)\n\nArguments:\n\nvtxgrid : a matrix such that `vtxgrid[i,j] > 0` represents free space,   otherwise an obstacle.\n\nKewyword Arguments:\n\ncell_width = 0.5 : determines the width of each grid cell when the   coordinates of the environment are transformed to continuous Cartesian   space.\ntransition_time = 2.0 : determines the nominal travel time for a robot   to move from one grid cell to an adjacent one.\npickup_zones = Int[] : a list of vertices that represent pick-up points\ndropoff_zones = Int[] : a list of vertices that represent drop-off points\n\n\n\n\n\n","category":"function"},{"location":"library/#GraphUtils.construct_factory_env_from_indicator_grid","page":"Core Types and Methods","title":"GraphUtils.construct_factory_env_from_indicator_grid","text":"construct_factory_env_from_indicator_grid\n\nArgs:     * grid: an indicator grid whose zero entries denote free space (non-zero     denotes obstacle)\n\n\n\n\n\n","category":"function"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Pages = [\"api.md\"]","category":"page"},{"location":"reference/#Docs","page":"API Reference","title":"Docs","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [GraphUtils]","category":"page"},{"location":"reference/#GraphUtils.AbstractCustomNEGraph","page":"API Reference","title":"GraphUtils.AbstractCustomNEGraph","text":"abstract type AbstractCustomNEGraph{G,N,E,ID} <: AbstractCustomNGraph{G,N,ID}\n\nAn abstract Custom Graph type, with an underlying graph of type G, nodes of type N with ids of type ID, and edges of type E. All concrete subtypes CG<:AbstractCustomNEGraph must implement the required AbstractCustomNGraph interface in addition to the following methods:\n\nout_edges(g::CG) : returns an integer-indexed forward adjacency list fadj   such that fadj[u::Int][v::Int] contains the custom edge associated   with u → v.\nin_edges(g::CG) : returns an integer-indexed backward adjacency list badj   such that badj[v::Int][u::Int] contains the custom edge associated   with u → v.\n\nThe above methods are implemented by default if g::CG has the following fields:\n\noutedges  ::Vector{Dict{Int,E}}\ninedges   ::Vector{Dict{Int,E}}\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.AgentID","page":"API Reference","title":"GraphUtils.AgentID","text":"AgentID\n\nSpecial helper for identifying agents.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.CachedElement","page":"API Reference","title":"GraphUtils.CachedElement","text":"CachedElement{E}\n\nA mutable container for caching things.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.CachedTreeNode","page":"API Reference","title":"GraphUtils.CachedTreeNode","text":"CachedTreeNode{ID} <: AbstractTreeNode{ID}\n\nAbstract type representing a node with a cached value. Concrete subtypes have a  cached element (accessed via cached_element(n)).\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.CubicSpline-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T<:Real","page":"API Reference","title":"GraphUtils.CubicSpline","text":"specify tangents explicitly\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.CustomEdge","page":"API Reference","title":"GraphUtils.CustomEdge","text":"CustomEdge{E,ID}\n\nA custom node type. Fields:\n\nid::ID\nval::E\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.CustomNEGraph","page":"API Reference","title":"GraphUtils.CustomNEGraph","text":"CustomNEGraph{G,N,E,ID}\n\nCustom graph type with custom edge and node types.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.CustomNETree","page":"API Reference","title":"GraphUtils.CustomNETree","text":"CustomNETree{G,N,E,ID}\n\nCustom tree type with custom edge and node types.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.CustomNGraph","page":"API Reference","title":"GraphUtils.CustomNGraph","text":"CustomGraph\n\nAn example concrete subtype of AbstractCustomNGraph.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.CustomNTree","page":"API Reference","title":"GraphUtils.CustomNTree","text":"CustomNTree\n\nAn example concrete subtype of AbstractCustomNTree.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.CustomNode","page":"API Reference","title":"GraphUtils.CustomNode","text":"CustomNode{N,ID}\n\nA custom node type. Fields:\n\nid::ID\nval::N\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.DistMatrixMap","page":"API Reference","title":"GraphUtils.DistMatrixMap","text":"DistMatrixMap\n\nMaps team size to the effective distance (computed by Djikstra) between leader (top left) vtxs. A DistMatrixMap is constructed by starting with a base environment grid graph, which is represented as a binary occupancy grid. The occupancy grid is then convolved with kernels of various sizes (which represent configurations of robots moving as a team). The output of each convolution represents a new occupancy grid corresponding to the workspace of the robot team. It is assumed that the \"lead\" robot is always in the top left of the configuration. If a team of robots wishes to query the distance to a particular target configuration, they pass the leader's current vtx, the leader's target vtx, and the team configuration (shape) to the DistMatrixMap, which returns the correct distance.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.IndicatorGrid","page":"API Reference","title":"GraphUtils.IndicatorGrid","text":"IndicatorGrid\n\nA matrix such that M[i,j] == 0 indicates \"free\" and M[i,j] == 1 indicates \"obstacle\".\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.TemplatedID","page":"API Reference","title":"GraphUtils.TemplatedID","text":"struct TemplatedID{T} <: AbstractID\n\nA simple way to dispatch by Node type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.VtxGrid","page":"API Reference","title":"GraphUtils.VtxGrid","text":"VtxGrid\n\nA matrix such that M[i,j] == v, where v is the index of the vertex whose coordinates are (i,j)\n\n\n\n\n\n","category":"type"},{"location":"reference/#GraphUtils.VtxID","page":"API Reference","title":"GraphUtils.VtxID","text":"VtxID\n\nSpecial helper for identifying schedule vertices.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.copy-Tuple{CachedElement}","page":"API Reference","title":"Base.copy","text":"Base.copy(e::CachedElement)\n\nShares the e.element, since it doesn't need to be replaced until set_element! is called. Copies e.is_up_to_date to preserve the cache state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.add_child!-Union{Tuple{ID}, Tuple{N}, Tuple{G}, Tuple{AbstractCustomNGraph{G, N, ID}, Any, Any, Any}} where {G, N, ID}","page":"API Reference","title":"GraphUtils.add_child!","text":"function add_child!(graph,parent,node,id)\n\nadd node child to graph with id id, then add edge parent → child\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.add_node!-Union{Tuple{ID}, Tuple{N}, Tuple{G}, Tuple{AbstractCustomNGraph{G, N, ID}, N, ID}} where {G, N, ID}","page":"API Reference","title":"GraphUtils.add_node!","text":"add_node!(g::AbstractCustomNGraph{G,N,ID},node::N,id::ID) where {G,N,ID}\n\nAdd node to g with associated id.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.add_parent!-Union{Tuple{ID}, Tuple{N}, Tuple{G}, Tuple{AbstractCustomNGraph{G, N, ID}, Any, N, ID}} where {G, N, ID}","page":"API Reference","title":"GraphUtils.add_parent!","text":"function add_parent!(graph,child,parent,id)\n\nadd node parent to graph with id id, then add edge parent → child\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.backup_descendants-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.backup_descendants","text":"backup_descendants(g::AbstractCustomNGraph{G,N,ID},template)\n\nReturn a dictionary mapping each node's id to the id of it's closest descendant matching template.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.cached_element-Tuple{CachedTreeNode}","page":"API Reference","title":"GraphUtils.cached_element","text":"cached_element(n::CachedTreeNode)   = n.element\n\nDefault method for retrieving the cached element of n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.cached_node_up_to_date-Tuple{CachedTreeNode}","page":"API Reference","title":"GraphUtils.cached_node_up_to_date","text":"cached_node_up_to_date(n::CachedTreeNode)\n\nCheck if n is up to date.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.capture_connected_nodes-Tuple{Any, Any, Any}","page":"API Reference","title":"GraphUtils.capture_connected_nodes","text":"capture_connected_nodes(G,vtxs,f)\n\nCollect the connected set of nodes in G that intersects with vtxs and such that f(v) == true for each v in the set. Args:\n\nvtxs::Union{Int,Vector{Int},Set{Int}}\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.clip-Tuple{Any, Any, Any}","page":"API Reference","title":"GraphUtils.clip","text":"`clip(a,b,c)`\n\nReturns the closest element to `a` on the interval `[b,c]`\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.collect_ancestors","page":"API Reference","title":"GraphUtils.collect_ancestors","text":"collect_ancestors(graph,v) = collect_subtree(graph,v,:in)\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.collect_descendants","page":"API Reference","title":"GraphUtils.collect_descendants","text":"collect_descendants(graph,v) = collect_subtree(graph,v,:out)\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.collect_subtree","page":"API Reference","title":"GraphUtils.collect_subtree","text":"collect_subtree(graph,v,dir=:out)\n\nReturn a set of all nodes in the subtree of graph starting from v in  direction dir.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.config_index_to_tuple-Tuple{Tuple{Int64, Int64}, Int64}","page":"API Reference","title":"GraphUtils.config_index_to_tuple","text":"config_index_to_tuple(shape::Tuple{Int,Int}, idx::Int)\n\nConvert a config index to a tuple coordinate representation. Assumes the following layout for config indices given shape (m,n):           1          2         ... n          ____________________________     1   | 1          2         ... n     2   | n+1        n+2       ... 2n     ... |     m   | (m-1)n+1  (m-1)n+2 ... m*n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.construct_edge_cache-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.construct_edge_cache","text":"construct_edge_cache(vtxs,vtx_map)\n\nReturns a cache such that cache[v] = {(0,1),(0,0),...}, the set of all valid directions in which a robot may move from vertex v.\n\nArguments:\n\nvtxs : a list of integer coordinates\nvtxmap : a matrix such that  `vtxmap[i,j] = v, wherevtxs[i,j] = v`.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.construct_expanded_zones-Tuple{Any, Any, Any}","page":"API Reference","title":"GraphUtils.construct_expanded_zones","text":"construct_expanded_zones(vtxs,vtx_map,pickup_zones,dropoff_zones;\n    shapes=[(1,1),(1,2),(2,1),(2,2)])\n\nA utility for constructing drop-off/pick-up zones where large-footprint objects need to be delivered. Returns a dictionary mapping vertices to a dict of shape=>vtxs for expanded size delivery zones. For each starting vertex, the expanded zone is selected as the appropriately sized region that overlaps with the original vertex, does not overlap with any obstacles, and has minimal overlap with all other vertices in the zone list.\n\nArguments:\n\nvtxs : a list of integer coordinates\nvtxmap : a matrix such that `vtxmap[i,j] == v, wherevtxs[v] == (i,j)`\nzones : a list of integer vertex indices identifying the zones to be   expanded\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.construct_factory_env_from_indicator_grid-Tuple{Any}","page":"API Reference","title":"GraphUtils.construct_factory_env_from_indicator_grid","text":"construct_factory_env_from_indicator_grid\n\nArgs:     * grid: an indicator grid whose zero entries denote free space (non-zero     denotes obstacle)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.construct_factory_env_from_vtx_grid-Tuple{Any}","page":"API Reference","title":"GraphUtils.construct_factory_env_from_vtx_grid","text":"construct_factory_env_from_vtx_grid(vtx_grid;kwargs...)\n\nArguments:\n\nvtxgrid : a matrix such that `vtxgrid[i,j] > 0` represents free space,   otherwise an obstacle.\n\nKewyword Arguments:\n\ncell_width = 0.5 : determines the width of each grid cell when the   coordinates of the environment are transformed to continuous Cartesian   space.\ntransition_time = 2.0 : determines the nominal travel time for a robot   to move from one grid cell to an adjacent one.\npickup_zones = Int[] : a list of vertices that represent pick-up points\ndropoff_zones = Int[] : a list of vertices that represent drop-off points\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.construct_regular_factory_world-Tuple{}","page":"API Reference","title":"GraphUtils.construct_regular_factory_world","text":"construct_regular_factory_world()\n\nReturns a GridFactoryEnvironment with regularly spaced obstacle regions surrounded by alternating pick-up and drop-off locations.\n\nKeyword Arguments:\n\nnobstaclesx = 2 : number of obstacles in x direction\nnobstaclesy = 2 : number of obstacles in y direction\nobs_width = [2;2] : obstacle width in both directions\nobs_offset = [1;1] : width of buffer region around each obstacle\nenv_pad = [1;1] : env pad\nenv_scale = 0.5 : determines the width of each grid cell when the   coordinates of the environment are transformed to continuous Cartesian   space.\ntransition_time = 2.0 : determines the nominal travel time for a robot   to move from one grid cell to an adjacent one.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.construct_vtx_grid-Union{Tuple{V}, Tuple{V, Any}} where V<:(Vector)","page":"API Reference","title":"GraphUtils.construct_vtx_grid","text":"`construct_vtx_grid`\n\nReturns a matrix M such that MV[i,j] == v, where v is the index of the vertex whose coordinates are (i,j)\n\nArguments:\n\nvtxs : a list of integer coordinates\ndims : the dimensions of the grid\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.construct_vtx_map-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.construct_vtx_map","text":"construct_vtx_map(vtxs,dims)\n\nReturns a matrix M such that MV[i,j] == v, where v is the index of the vertex whose coordinates are (i,j)\n\nArguments:\n\nvtxs : a list of integer coordinates\ndims : the dimensions of the grid\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.contract_by_predicate-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.contract_by_predicate","text":"contract_by_node_type(g,f)\n\nConstructs a new graph of the same type as g, whose nodes are formed by those  for which f(n) == true. Edges are contracted so that, e.g.  \tn1 => n2 => n3 => n4 collapses to n1 => n4  \tif  f(n1) && !(f(n2)) && !(f(n3)) && f(n4).\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.convolve_with_occupancy_kernel-Tuple{IndicatorGrid, Matrix{Int64}}","page":"API Reference","title":"GraphUtils.convolve_with_occupancy_kernel","text":"convolve_with_occupancy_kernel(indicator_grid::IndicatorGrid,kernel)\n\nConstruct a new indicator grid corresponding to convolution of the original grid with a kernel. The second argument may be a Matrix{Int} or a Tuple{Int,Int} indicating the size for a ones() kernel.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.curve_turn_rate-Tuple{ParametricSpline, Real}","page":"API Reference","title":"GraphUtils.curve_turn_rate","text":"`curve_turn_rate(S::ParametricSpline,t::Real)`\ncomputes the turn rate (w.r.t. t) of the tangent vector to a curve.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.depth_first_search","page":"API Reference","title":"GraphUtils.depth_first_search","text":"depth_first_search(graph,v,goal_function,expand_function,\n\tneighbor_function=outneighbors)\n\nReturns the first vertex satisfying goalfunction(graph,v). Only expands v if  expandfunction(graph,v) == true.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.depth_first_search-2","page":"API Reference","title":"GraphUtils.depth_first_search","text":"depth_first_search(node::AbstractTreeNode,goal_function,expand_function,\n\tneighbor_function=outneighbors)\n\nReturns the first vertex satisfying goalfunction(graph,v). Only expands v if  expandfunction(graph,v) == true.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.dfs_check_cycle","page":"API Reference","title":"GraphUtils.dfs_check_cycle","text":"dfs_check_cycle(graph,v,neighbor_func=inneighbors)\n\nCheck if graph contains a cycle with v in it\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.draw_random_uniform-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.draw_random_uniform","text":"draw_random_elements(vec,n)\n\nDraw n elements uniformly at random (without replacement) from vec.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.edge_cover","page":"API Reference","title":"GraphUtils.edge_cover","text":"edge_cover(G,vtxs,mode=:all)\n\nGet all edges coming from vertices vtxs. If mode=:in, just collect incoming edges. If :out, just outgoing. If :all, both.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.edge_source-Tuple{Any}","page":"API Reference","title":"GraphUtils.edge_source","text":"edge_source(edge)\n\nReturns the ID of the source node of an edge. Part of the required interface for edges in an AbstractCustomNEGraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.edge_target-Tuple{Any}","page":"API Reference","title":"GraphUtils.edge_target","text":"edge_target(edge)\n\nReturns the ID of the target node of an edge. Part of the required interface for edges in an AbstractCustomNEGraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.edge_val-Tuple{Any}","page":"API Reference","title":"GraphUtils.edge_val","text":"edge_val(edge)\n\nReturns the value associated with an edge. Part of the optional interface for edges in an AbstractCustomNEGraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.eligible_predecessors","page":"API Reference","title":"GraphUtils.eligible_predecessors","text":"eligible_predecessors(node)\n\nIdentifies the types (and how many) of eligible predecessors to node Return type: Dict{DataType,Int}\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.eligible_successors","page":"API Reference","title":"GraphUtils.eligible_successors","text":"eligible_successors(node)\n\nIdentifies the types (and how many) of eligible successors to node Return type: Dict{DataType,Int}\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.exclusive_edge_cover","page":"API Reference","title":"GraphUtils.exclusive_edge_cover","text":"exclusive_edge_cover(G,vtxs,mode)\n\nReturns the edge cover, minus all edges whose sources and edges are both contained within vtxs.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.filtered_topological_sort-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.filtered_topological_sort","text":"filtered_topological_sort(graph,template)\n\nIterator over nodes that match template.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.find_index_in_sorted_array-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.find_index_in_sorted_array","text":"`find_index_in_sorted_array(array, x)`\n\nAssumes that array is already sorted. Returns index at which x would need to\nbe inserted in order to maintain ordering of array. Chooses the smallest\nindex in the case of a tie.\n\nLooks like  \"Base.searchsorted\" does the same thing as this.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.get_all_root_nodes-Tuple{Any}","page":"API Reference","title":"GraphUtils.get_all_root_nodes","text":"`get_all_root_nodes`\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.get_all_terminal_nodes-Tuple{Any}","page":"API Reference","title":"GraphUtils.get_all_terminal_nodes","text":"`get_all_terminal_nodes`\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.get_biggest_tree","page":"API Reference","title":"GraphUtils.get_biggest_tree","text":"get_biggest_tree(graph,dir=:in)\n\nReturn the root/terminal vertex corresponding to the root of the largest tree in  the graph.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.get_cached_value!-Tuple{CachedTreeNode}","page":"API Reference","title":"GraphUtils.get_cached_value!","text":"get_cached_value!(n::CachedTreeNode)\n\nReturn the up to date cached value of n. This triggers a reach back to parent  nodes if necessary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.get_dist_matrix-Tuple{Any}","page":"API Reference","title":"GraphUtils.get_dist_matrix","text":"`get_dist_matrix(G)`\n\nGet the distance matrix corresponding to the edge weights of a graph\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.get_distance","page":"API Reference","title":"GraphUtils.get_distance","text":"get_distance(mtx_map::DistMatrixMap,v1::Int,v2::Int,shape::Tuple{Int,Int}=(1,1),config_idx=1)\n\nReturns the length of the minimum distance collision-free path between vertices v1 and v2 for an object of footprint shape.\n\nArguments:\n\nmtx_map : a DistMatrixMap\nv1 : an integer corresponding to the source vertex in the graph\nv2 : an integer corresponding to the destination vertex in the graph\nshape : the footprint of the object that will move between v1 and v2\nconfig_idx : an integer that identifies the position of the reference   point within the footprint.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.get_element-Tuple{CachedElement}","page":"API Reference","title":"GraphUtils.get_element","text":"get_element(n::CachedElement)\n\nRetrieve the element stored in n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.get_files_matching","page":"API Reference","title":"GraphUtils.get_files_matching","text":"get_files_matching(base_path,ext,keywords=[])\n\nGet all files in a directory that match the extension ext, and (optionally) which contain any of keywords\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.get_graph-Tuple{GraphUtils.AbstractCustomGraph}","page":"API Reference","title":"GraphUtils.get_graph","text":"get_graph(g::AbstractCustomNGraph{G,N,ID})\n\nreturn the underlying graph of type G.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.get_nodes-Tuple{AbstractCustomNGraph}","page":"API Reference","title":"GraphUtils.get_nodes","text":"get_nodes(g::AbstractCustomNGraph{G,N,ID})\n\nReturn the vector Vector{N} of g's nodes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.get_root_node-Tuple{AbstractTreeNode}","page":"API Reference","title":"GraphUtils.get_root_node","text":"get_root_node(n::AbstractTreeNode{E,ID}) where {E,ID}\n\nReturn the root node of a tree\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.get_vtx_ids-Tuple{AbstractCustomNGraph}","page":"API Reference","title":"GraphUtils.get_vtx_ids","text":"get_vtx_ids(g::AbstractCustomNGraph{G,N,ID})\n\nreturn the vector Vector{ID} of g's unique vertex ids.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.get_vtx_map-Tuple{AbstractCustomNGraph}","page":"API Reference","title":"GraphUtils.get_vtx_map","text":"get_vtx_map(g::AbstractCustomNGraph{G,N,ID})\n\nreturn a data structure (e.g, a 'Dict{ID,Int}') mapping node id to node index.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.global_verbosity-Tuple{}","page":"API Reference","title":"GraphUtils.global_verbosity","text":"global_verbosity()\n\nQuery the global verbosity setting (VERBOSITY::Int)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.has_ancestor-Tuple{AbstractTreeNode, AbstractTreeNode}","page":"API Reference","title":"GraphUtils.has_ancestor","text":"has_ancestor(node::AbstractTreeNode,other::AbstractTreeNode)\n\nCheck if other is an ancestor of node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.has_descendant-Tuple{AbstractTreeNode, AbstractTreeNode}","page":"API Reference","title":"GraphUtils.has_descendant","text":"has_descendant(node::AbstractTreeNode,other::AbstractTreeNode)\n\nCheck if other is a descendant of node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.has_path-Tuple{Any, Any, Any}","page":"API Reference","title":"GraphUtils.has_path","text":"has_path(graph,v,v2)\n\nReturn true if graph has a path from v to v2\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.in_edges-Tuple{GraphUtils.AbstractCustomNEGraph}","page":"API Reference","title":"GraphUtils.in_edges","text":"in_edges(g::AbstractCustomNEGraph{G,N,E,ID})\n\nReturns an integer-indexed backward adjacency list badj (e.g., badj::Vector{Dict{Int,E}}) such that badj[v::Int][u::Int] contains the custom edge associated with u → v.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.initialize_dense_vtx_grid-Tuple{Int64, Int64}","page":"API Reference","title":"GraphUtils.initialize_dense_vtx_grid","text":"`initialize_dense_vtx_grid`\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.initialize_grid_graph_from_vtx_grid-Tuple{M} where M<:Union{VtxGrid, Matrix{Int64}}","page":"API Reference","title":"GraphUtils.initialize_grid_graph_from_vtx_grid","text":"Returns a grid graph that represents a 2D environment with regularly spaced\nrectangular obstacles\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.initialize_grid_graph_with_obstacles","page":"API Reference","title":"GraphUtils.initialize_grid_graph_with_obstacles","text":"Returns a grid graph that represents a 2D environment with obstacles placed\nover specific vertices\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.initialize_regular_grid_graph-Tuple{}","page":"API Reference","title":"GraphUtils.initialize_regular_grid_graph","text":"Returns a grid graph that represents a 2D environment with regularly spaced\nrectangular obstacles\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.initialize_regular_indicator_grid-Tuple{}","page":"API Reference","title":"GraphUtils.initialize_regular_indicator_grid","text":"Returns a grid that represents a 2D environment with regularly spaced\nrectangular obstacles.\n\nIndicator grid values:\n    0 == FREE\n    1 == OCCUPIED\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.initialize_vtx_grid_from_indicator_grid-Tuple{Any}","page":"API Reference","title":"GraphUtils.initialize_vtx_grid_from_indicator_grid","text":"initialize_vtx_grid_from_indicator_grid()\n\nArgs:     * grid: an indicator grid, where grid[i,j] == 0 denotes that cell (i,j) is     free, and grid[i,j] != 0 denotes that the cell is impassable.\n\nReturns:     * A matrix whose non-zero elements represent the ids of vertices in a graph     embedded in the 2D grid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.insert_to_sorted_array!-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.insert_to_sorted_array!","text":"`insert_to_sorted_array!(array, x)`\n\nAssumes that array is already sorted. Inserts new element x so that\narray remains sorted. Requires that Base.isless(a::C,b::C) where\nC==typeof(x) be implemented.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.intersections_between_circles-NTuple{4, Any}","page":"API Reference","title":"GraphUtils.intersections_between_circles","text":"intersections_between_circles(v1,v2,r1,r2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.is_terminal_node-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.is_terminal_node","text":"`isroot_node(G,v)`\n\nInputs:\n    `G` - graph\n    `v` - query vertex\n\nOutputs:\n    returns `true` if vertex v has no outneighbors\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.is_up_to_date-Tuple{CachedElement}","page":"API Reference","title":"GraphUtils.is_up_to_date","text":"is_up_to_date(n::CachedElement)\n\nCheck if the n is up to date.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.linear_interp-Tuple{Any, Any, Any}","page":"API Reference","title":"GraphUtils.linear_interp","text":"linear_interpolation\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.make_edge-Union{Tuple{G}, Tuple{G, Any, Any, Any}} where G","page":"API Reference","title":"GraphUtils.make_edge","text":"make_edge(g::G,u,v,val) where {G}\n\nConstruct an edge u → v of type _edge_type(g) based on val. Default behavior is to throw an error.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.matches_keywords-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.matches_keywords","text":"matches_keywords(p,keywords)\n\nCheck if any of the keywords occurs in p.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.matches_template-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, Type{S}}} where {T, S}","page":"API Reference","title":"GraphUtils.matches_template","text":"matches_template(template,node)\n\nChecks if a candidate node satisfies the criteria encoded by template.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.nested_default_dict_get-Tuple{Any, Any, Vararg{Any}}","page":"API Reference","title":"GraphUtils.nested_default_dict_get","text":"nested_default_dict_get(dict,k,keylist...;default=nothing)\n\nQuery into an arbitrarily deep nested dict until finding a non-dict value or  returning default when the current key does not point to a dict. Example @juliadict = Dict() nested_default_dict_set!(dict,1,2,\"val\") nested_default_dict_set!(dict,1,2,3,\"other val\") nested_default_dict_get(dict,1,2) == \"val\" nested_default_dict_get(dict,1,2,3) == \"val\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.nested_default_dict_set!-Tuple{Any, Any, Any, Vararg{Any}}","page":"API Reference","title":"GraphUtils.nested_default_dict_set!","text":"nested_default_dict_set!(dict,keylist...,[val])\n\nSets the value of a nested dictionary, indexed by a list of keys, to val. If  the full keylist does not yet exist, create the intermediate dicts along the  way. Example: @juliadict = Dict() nested_default_dict_set!(dict,1,2,3,\"my val\")\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.node_id-Tuple{Any}","page":"API Reference","title":"GraphUtils.node_id","text":"node_id(node)\n\nReturn the id of a node. Part of the required node interface for nodes in an  AbstractCustomNGraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.node_iterator-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.node_iterator","text":"node_iterator(graph,it)\n\nWraps an iterator over ids or vertices to return the corresponding node at each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.node_val-Tuple{Any}","page":"API Reference","title":"GraphUtils.node_val","text":"node_val(node)\n\nReturn the value associated with a node. Part of the optional node interface for nodes in an AbstractCustomNGraph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.num_eligible_predecessors-Tuple{Any}","page":"API Reference","title":"GraphUtils.num_eligible_predecessors","text":"num_eligible_predecessors(node)\n\nReturns the total number of eligible predecessors to node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.num_eligible_successors-Tuple{Any}","page":"API Reference","title":"GraphUtils.num_eligible_successors","text":"num_eligible_successors(node)\n\nReturns the total number of eligible successors to node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.num_required_predecessors-Tuple{Any}","page":"API Reference","title":"GraphUtils.num_required_predecessors","text":"num_required_predecessors(node)\n\nReturns the total number of required predecessors to node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.num_required_successors-Tuple{Any}","page":"API Reference","title":"GraphUtils.num_required_successors","text":"num_required_successors(node)\n\nReturns the total number of required successors to node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.one_hot-Union{Tuple{T}, Tuple{Type{T}, Int64, Int64}} where T","page":"API Reference","title":"GraphUtils.one_hot","text":"one_hot(::Type{T},n::Int,i::Int) where {T}\n\nReturns a Vector{T} of length n such that v[i] == 1 and v[j] .== 0 for all j != i.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.out_edges-Tuple{GraphUtils.AbstractCustomNEGraph}","page":"API Reference","title":"GraphUtils.out_edges","text":"out_edges(g::AbstractCustomNEGraph{G,N,E,ID})\n\nReturns an integer-indexed forward adjacency list fadj (e.g., fadj::Vector{Dict{Int,E}}) such that fadj[u::Int][v::Int] contains the custom edge associated with u → v.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.pad_matrix-Union{Tuple{T}, Tuple{Matrix{T}, Tuple{Int64, Int64}, T}} where T","page":"API Reference","title":"GraphUtils.pad_matrix","text":"helper to pad a matrix with some value around the edges\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.propagate_backward!-Tuple{CachedTreeNode, CachedTreeNode, Vararg{Any}}","page":"API Reference","title":"GraphUtils.propagate_backward!","text":"propagate_backward!(child::CachedTreeNode,parent::CachedTreeNode,args...)\n\nPropagate information from child to parent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.propagate_backward!-Tuple{CachedTreeNode, Vararg{Any}}","page":"API Reference","title":"GraphUtils.propagate_backward!","text":"propagate_backward!(n::CachedTreeNode,args...)\n\nPropagate information up the tree from n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.propagate_forward!-Tuple{CachedTreeNode, CachedTreeNode, Vararg{Any}}","page":"API Reference","title":"GraphUtils.propagate_forward!","text":"propagate_forward!(parent::CachedTreeNode,child::CachedTreeNode,args...)\n\nPropagate information from parent to child.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.propagate_forward!-Tuple{CachedTreeNode, Vararg{Any}}","page":"API Reference","title":"GraphUtils.propagate_forward!","text":"propagate_forward!(n::CachedTreeNode,args...)\n\nPropagate information down the tree from n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.read_env-Tuple{Any}","page":"API Reference","title":"GraphUtils.read_env","text":"read_env(io)\n\nLoads saved environment from a .toml file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.recompute_cached_distances!-Tuple{SparseDistanceMatrix}","page":"API Reference","title":"GraphUtils.recompute_cached_distances!","text":"recompute_cached_distances!\n\nRecompute all cached distances (important if, e.g., the graph has been modified)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.redirect_to_files-Tuple{Any, Any, Any}","page":"API Reference","title":"GraphUtils.redirect_to_files","text":"redirect_to_files(dofunc, outfile, errfile)\n\nredirects output of stdout and stderr to outfile and errfile, respectively. Usage: \tredirect_to_files(prefix * \".log\", prefix * \".err\") do     \tcompute(...) \tend\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.rem_node!-Union{Tuple{ID}, Tuple{N}, Tuple{G}, Tuple{AbstractCustomNGraph{G, N, ID}, ID}} where {G, N, ID}","page":"API Reference","title":"GraphUtils.rem_node!","text":"rem_node!\n\nremoves a node (by id) from g. Note about LightGraphs.rem_vertex!: \"internally the removal is performed swapping the vertices v and nv(G), and  removing the last vertex nv(G) from the graph\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.remap_idx","page":"API Reference","title":"GraphUtils.remap_idx","text":"remap_idx(m::SparseDistanceMatrix,v,config)\n\nMaps an index and configuration from the base grid to the transformed grid represented by m.graph. config represents the position of the query pt relative to the coordinates that correspond to v.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.replace_node!-Union{Tuple{ID}, Tuple{N}, Tuple{G}, Tuple{AbstractCustomNGraph{G, N, ID}, N, ID}} where {G, N, ID}","page":"API Reference","title":"GraphUtils.replace_node!","text":"replace_node!(g::AbstractCustomNGraph{G,N,ID},node::N,id::ID) where {G,N,ID}\n\nReplace the current node associated with id with the new node node.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.required_predecessors","page":"API Reference","title":"GraphUtils.required_predecessors","text":"required_predecessors(node)\n\nIdentifies the types (and how many) of required predecessors to node Return type: Dict{DataType,Int}\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.required_successors","page":"API Reference","title":"GraphUtils.required_successors","text":"required_successors(node)\n\nIdentifies the types (and how many) of required successors to node Return type: Dict{DataType,Int}\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.resample_array-Tuple{Matrix{Float64}, Any, Any}","page":"API Reference","title":"GraphUtils.resample_array","text":"resample array\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.set_cached_node_up_to_date!","page":"API Reference","title":"GraphUtils.set_cached_node_up_to_date!","text":"set_cached_node_up_to_date!(n::CachedTreeNode,val=true)\n\nSet \"up to date\" status of n to val.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.set_element!-Tuple{CachedElement, Any}","page":"API Reference","title":"GraphUtils.set_element!","text":"set_element!(n::CachedElement,g)\n\nSet the element stored in n. Does NOT set the is_up_to_date flag.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.set_global_verbosity!-Tuple{Int64}","page":"API Reference","title":"GraphUtils.set_global_verbosity!","text":"set_global_verbosity!(val::Int)\n\nSet the global verbosity to val\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.set_time_stamp!","page":"API Reference","title":"GraphUtils.set_time_stamp!","text":"set_time_stamp!(n::CachedElement,t=time())\n\nSet the time stamp of n.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.set_up_to_date!","page":"API Reference","title":"GraphUtils.set_up_to_date!","text":"set_up_to_date!(n::CachedElement,val::Bool=true)\n\nSet the time stamp of n.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.sprint_padded-Tuple{Any}","page":"API Reference","title":"GraphUtils.sprint_padded","text":"sprint_padded(i,pad=3,leftaligned=false)\n\nPads the string representation of i\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.sprint_padded_list-Tuple{IO, Any}","page":"API Reference","title":"GraphUtils.sprint_padded_list","text":"sprintpaddedlist(vec,pad=3,leftaligned=false)\n\nReturns a string as in:    julia> sprint_padded_list([1,2,3],3)    \"[  1  2  3]\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.swap_with_end_and_delete!-Tuple{Vector, Any}","page":"API Reference","title":"GraphUtils.swap_with_end_and_delete!","text":"swap_with_end_and_delete!(vec,v)\n\nReplaces vec[v] with last(vec), then removes the last element from vec\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.tangent_rate-Tuple{ParametricSpline, Real}","page":"API Reference","title":"GraphUtils.tangent_rate","text":"`tangent_rate(S::ParametricSpline,t::Real)`\nComputes the rate (w.r.t. t) at which the tangent vector to a curve is\nchanging.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.time_stamp-Tuple{CachedElement}","page":"API Reference","title":"GraphUtils.time_stamp","text":"time_stamp(n::CachedElement)\n\nReturn the time_stamp at which n was last modified.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.topological_sort-Tuple{Any}","page":"API Reference","title":"GraphUtils.topological_sort","text":"topological_sort(G)\n\nReturns a topological sort of the vertices of a graph, with the property that v1 < v2 iff there is not forward path through the graph from v2 to v1. G must be non-cyclic. Can handle disjoint graphs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.transform_iter-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.transform_iter","text":"transform_iter(f, it) = Base.Iterators.accumulate((a,b)->f(b), it)\n\nTransform iterator that applies f to each element of it.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.transplant!-Tuple{Any, Any, Any}","page":"API Reference","title":"GraphUtils.transplant!","text":"transplant!(graph,old_graph,id)\n\nShare node with id in old_graph to graph with the same id.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.update_element!","page":"API Reference","title":"GraphUtils.update_element!","text":"update_element!(n::CachedTreeNode,element,args...)\n\nUpdate cached element of n, and propagate relevant information forward and  backward via propagate_forward! and propagate_backward!\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.update_element!-Tuple{CachedElement, Any}","page":"API Reference","title":"GraphUtils.update_element!","text":"update_element!(n::CachedElement,g)\n\nSet the element of n to g, update the is_up_to_date flag and the time stamp.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.validate_edge_cache-Tuple{Any, Any, Any}","page":"API Reference","title":"GraphUtils.validate_edge_cache","text":"validate_edge_cache(G,vtxs,cache)\n\nVerifies that for a graph G embedded in space such that vertex v has coordinates vtxs[v], every edge v₁ → v₂ is stored in the edge cache. In other words, for every edge v₁ → v₂, the unit direction vector obtained by vtxs[v₂] - vtxs[v₁] is a member of cache[v₁].\n\nArguments:\n\nG : a graph on which the functions vertices and outneighbors can be   called\nvtxs : a list of integer coordinates\ncache : an edge cache such that e.g. cache[v] = {(0,1),(0,0),...}, the   set of all valid directions in which a robot may move from vertex v\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.validate_embedded_tree","page":"API Reference","title":"GraphUtils.validate_embedded_tree","text":"validate_embedded_tree(graph,f=v->get_node(graph,v))\n\nVerify that all graph edges are mirrored by the parent-child structure stored in the nodes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GraphUtils.validate_expanded_zones-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.validate_expanded_zones","text":"validate_expanded_zones(vtx_map,expanded_zones)\n\nVerify that all vertices of each expanded zone do not overlap with obstacle regions, and that each expanded zone contains the original vertex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.validate_sub_tree-Union{Tuple{N}, Tuple{ID}} where {ID, N<:AbstractTreeNode{ID}}","page":"API Reference","title":"GraphUtils.validate_sub_tree","text":"validate_tree(n::AbstractTreeNode)\n\nEnsure that the subtree of n is in fact a tree–no cycles, and no duplicate ids\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.validate_tree-Tuple{AbstractTreeNode}","page":"API Reference","title":"GraphUtils.validate_tree","text":"validate_tree(n::AbstractTreeNode)\n\nEnsure that the transform tree is in fact a tree–no cycles, and no duplicate ids\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.wrap_get-Union{Tuple{A}, Tuple{N}, Tuple{R}, Tuple{A, Any}} where {R, N, A<:AbstractArray{R, N}}","page":"API Reference","title":"GraphUtils.wrap_get","text":"wrap_get\n\nIndex into array a by first wrapping the indices idx.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.wrap_idx-Tuple{Any, Any}","page":"API Reference","title":"GraphUtils.wrap_idx","text":"wrap_idx(n,idx)\n\nWrap index to a one-dimensional array of length n\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.wrap_to_pi-Tuple{Any}","page":"API Reference","title":"GraphUtils.wrap_to_pi","text":"`wrap_to_pi(θ₀)`\n\nwraps the angle θ₀ to a value in (-π,π]\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.@log_info-Tuple{Any, Any, Vararg{Any}}","page":"API Reference","title":"GraphUtils.@log_info","text":"@log_info\n\nA helper macro for printing at various verbosity levels. Usage: \t@log_info(limit::Int,level::Int,msg...) \t@log_info(limit::Int,solver,msg...) Args:\n\nlimit::Int - logging threshold\nlevel::Int - the verbosity level\nmsg... - message to print if level > limit\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphUtils","category":"page"},{"location":"#GraphUtils","page":"Home","title":"GraphUtils","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the GraphUtils.jl documentation. The purpose of this  project is to provide an example package structure which can be easily copied and modified.","category":"page"},{"location":"#Where-to-begin?","page":"Home","title":"Where to begin?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting_started.md\"]\nDepth = 2","category":"page"},{"location":"#Core-Types","page":"Home","title":"Core Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]\nDepth = 2","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"reference.md\"]\nDepth = 2","category":"page"}]
}
